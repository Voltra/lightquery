{"version":3,"sources":["../../../src/utils/helpers.js"],"names":["InvalidArgumentError","helpers","string","capitalizeFirst","str","first","charAt","toUpperCase","rest","substring","parsePx","nbStr","replace","maybeFloat","parseFloat","isNaN","spacedListString","regex","replacement","splitter","toArray","split","css_variables","trailing","no_trailing","functions","valid_name_regex","valid_firstChar_regex","invalid_otherChar_regex","newName","test","plugin","isValidPluginType","includes","doForPluginType","pluginType","onGlobal","onInstance","onUnknown","constructorLQ","baseName","nameRegex","arrayLike","array","isEmpty","arr","length","Array","elements","getElement","domEl","Document","Window","document","documentElement","Element","isElement","el","Node","DocumentFragment","forElements","onElement","onElements","nameForStrict","LightqueryCollection","NodeList","forEach","e","forElement","element","onLq","onString"],"mappings":"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","sourceRoot":"./src/","sourcesContent":["import \"./typedefs\"\r\nimport InvalidArgumentError from \"../errors/InvalidArgumentError\";\r\n\r\nconst helpers = {\r\n    string: {\r\n        /**\r\n         * Capitalize the first letter of a string\r\n         * @param {string} str - The string to capitalize\r\n         * @returns {string}\r\n         */\r\n        capitalizeFirst(str){\r\n            const first = str.charAt(0).toUpperCase();\r\n            const rest = str.substring(1);\r\n\r\n            return `${first}${rest}`;\r\n        },\r\n\r\n\t\t/**\r\n\t\t * Parse a pixel string\r\n\t\t * @param {string} str - The string to parse\r\n\t\t * @returns {number|null}\r\n\t\t */\r\n\t\tparsePx(str){\r\n        \tconst nbStr = str.replace(/px$/i, \"\");\r\n        \tconst maybeFloat = parseFloat(nbStr);\r\n        \treturn isNaN(maybeFloat) ? null : maybeFloat;\r\n\t\t}\r\n    },\r\n    spacedListString: {\r\n        regex: /(\\S)\\s+(\\S)/g,\r\n        replacement: \"$1 $2\",\r\n        splitter: \" \",\r\n\t\t/**\r\n\t\t * Convert a spaced list string to an array of strings\r\n\t\t * @param   {string}   str - The spaced list string to convert\r\n\t\t * @returns {string[]}\r\n\t\t */\r\n\t\ttoArray(str){\r\n\t\t\treturn str\r\n\t\t\t.replace(this.regex, this.replacement)\r\n\t\t\t.split(this.splitter);\r\n\t\t},\r\n    },\r\n    css_variables: {\r\n        regex: {\r\n            trailing: /^--\\w+(?:\\w|-)*$/,\r\n            no_trailing: /^\\w+(?:\\w|-)*$/,\r\n        },\r\n    },\r\n    functions: {\r\n        valid_name_regex: /^[$µA-Z_][0-9A-Z_$µ]*$/i,\r\n        valid_firstChar_regex: /^[$A-Z_]$/i,\r\n        invalid_otherChar_regex: /[^0-9A-Z_$]/ig,\r\n\t\t/**\r\n\t\t * Construct a new function name from the given seed\r\n\t\t * @param   {string} str - The seed\r\n\t\t * @returns {string}\r\n\t\t */\r\n\t\tnewName(str){\r\n\t\t\tif(this.valid_name_regex.test(str))\r\n\t\t\t\treturn str;\r\n\r\n\t\t\tif(!this.valid_firstChar_regex.test(str.charAt(0)))\r\n\t\t\t\treturn this.newName(`$${str}`);\r\n\r\n\t\t\treturn str.replace(this.invalid_otherChar_regex, \"_\");\r\n\t\t},\r\n    },\r\n    plugin: {\r\n\t\t/**\r\n\t\t * Determine whether or not the given plugin string is a valid plugin type\r\n\t\t * @param   {string|PluginType}  str - The plugin type to check\r\n\t\t * @returns {boolean}\r\n\t\t */\r\n\t\tisValidPluginType(str){\r\n\t\t\t//TODO: Maybe refactor to use enum\r\n\t\t\treturn typeof str == \"string\"\r\n\t\t\t&& [\"instance\", \"global\"].includes(str);\r\n\t\t},\r\n\t\tdoForPluginType({ pluginType, onGlobal, onInstance, onUnknown }){\r\n\t\t\tswitch(pluginType){\r\n\t\t\t\tcase \"global\":\r\n\t\t\t\t\treturn onGlobal();\r\n\r\n\t\t\t\tcase \"instance\":\r\n\t\t\t\t\treturn onInstance();\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn onUnknown();\r\n\t\t\t}\r\n\t\t},\r\n\t},\r\n    constructorLQ: {\r\n        baseName: \"lightqueryObject\",\r\n        nameRegex: /^lightqueryObject(\\d*)$/,\r\n    },\r\n    arrayLike: {\r\n\t\t/**\r\n\t\t * Transform an array like object to an actual array\r\n\t\t * @param   {Iterable|any} arrayLike - The object to convert to an array\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\ttoArray(arrayLike){\r\n\t\t\t// return [].slice.call(arrayLike);\r\n\t\t\treturn [...arrayLike];\r\n\t\t},\r\n\t},\r\n    array: {\r\n\t\t/**\r\n\t\t * Determine whether or not an array is empty\r\n\t\t * @param   {Array|Iterable|any} arr - The array\r\n\t\t * @returns {boolean}\r\n\t\t */\r\n\t\tisEmpty(arr){\r\n\t\t\treturn arr.length === 0\r\n\t\t\t||  arr == []\r\n\t\t\t|| arr == new Array();\r\n\t\t},\r\n\t},\r\n    elements: {\r\n\t\t/**\r\n\t\t * Get an element from a DOM element\r\n\t\t * @param {DomElementType} domEl\r\n\t\t * @returns {Element}\r\n\t\t */\r\n    \tgetElement(domEl){\r\n\t\t\tif(domEl instanceof Document || domEl instanceof Window)\r\n\t\t\t\treturn this.getElement(document.documentElement);\r\n\t\t\telse if(domEl instanceof Element)\r\n\t\t\t\treturn domEl\r\n\t\t\telse // DocumentFragment\r\n\t\t\t\treturn domEl; //TODO: Check if OK (or if ShadowRoot should even be part of type alias)\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Determine whether or not the given element is a DOM element\r\n\t\t * @param el\r\n\t\t * @returns {boolean}\r\n\t\t */\r\n        isElement(el){\r\n            return el && (el instanceof Node || el instanceof Element || el instanceof DocumentFragment);\r\n        },\r\n\r\n\t\t/**\r\n\t\t * Execute code for each element\r\n\t\t * @param {object} args\r\n\t\t * @param {ElementsOrLightquery} args.elements - The elements to execute code for\r\n\t\t * @param {ElementCallback} args.onElement - The callback for single elements\r\n\t\t * @param {ElementsCallback} args.onElements - The callback for iterable of elements\r\n\t\t * @param {string} args.nameForStrict - The name for error messages if strict mode is on\r\n\t\t * @param {typeof LightqueryCollection} args.LightqueryCollection - The class for the lightquery result set\r\n\t\t */\r\n        forElements({ elements, onElement, onElements, nameForStrict, LightqueryCollection }){\r\n            if(elements instanceof LightqueryCollection || elements instanceof NodeList){\r\n                onElements(elements);\r\n            }else if(this.isElement(elements)){\r\n                onElement(this.getElement(elements));\r\n            }else{\r\n                if(elements.forEach){\r\n                    elements.forEach(e => {\r\n                        if(!this.isElement(e)){\r\n                            throw new InvalidArgumentError(`Expected elements to contain (only) elements in LightqueryCollection${nameForStrict}`);\r\n                        }else{\r\n                            onElement(this.getElement(e));\r\n                        }\r\n                    });\r\n                }else{\r\n                    throw new InvalidArgumentError(`Expected elements to be iterable or an element in LightqueryCollection${nameForStrict}`);\r\n                }\r\n            }\r\n        },\r\n\r\n\t\t/**\r\n\t\t * Execute code for an element\r\n\t\t * @param {object} args\r\n \t\t * @param {ElementOrLightquery|string} args.element - The element to execute code for\r\n\t\t * @param {LightqueryCollectionCallback} args.onLq - The callback for a lightquery collection\r\n\t\t * @param {ElementCallback} args.onElement - The callback for an element\r\n\t\t * @param {GenericCallback<string>} args.onString - The callback for a CSS selector\r\n\t\t * @param {string} args.nameForStrict - The name for error messages if strict mode is on\r\n\t\t * @param {typeof LightqueryCollection} args.LightqueryCollection - The class for the lightquery result set\r\n\t\t */\r\n        forElement({ element, onLq, onElement, onString, nameForStrict, LightqueryCollection}){\r\n\t\t\tif(element instanceof LightqueryCollection){\r\n\t\t\t\tonLq(element);\r\n\t\t\t}else if(this.isElement(element)){\r\n\t\t\t\tonElement(element);\r\n\t\t\t}else if(typeof element === \"string\"){\r\n\t\t\t\tonString(element);\r\n\t\t\t}else{\r\n\t\t\t\tthrow new InvalidArgumentError(`Expected element to be an Element, a LightqueryCollection or a CSS selector in LightqueryCollection${nameForStrict}`);\r\n\t\t\t}\r\n\t\t}\r\n    },\r\n};\r\n\r\nexport default helpers;\r\n"],"file":"helpers.js"}